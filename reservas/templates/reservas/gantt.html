{% extends "core/base.html" %}
{% load static %}

{% block title %}HospedAI — Planejamento (Gantt){% endblock %}

{% block content %}
<style>
  :root{
    --ink:#0f172a;
    --muted:#6b7280;
    --primary:#4f46e5;
    --primary-2:#6366f1;
    --line:#e5e7eb;
    --bg:#f7f8fc;
  }

  .gantt-toolbar{
    display:flex; gap:12px; align-items:center; justify-content:space-between;
    margin: 8px 0 14px;
  }
  .gantt-toolbar .side{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .gantt-toolbar input[type="date"],
  .gantt-toolbar select,
  .gantt-toolbar button{
    border:1px solid var(--line); background:#fff; color:var(--ink);
    padding:.5rem .75rem; border-radius:10px; cursor:pointer;
  }
  .gantt-toolbar button:hover{ border-color: var(--primary); }

  .gantt-wrap{
    background:var(--bg);
    border-radius:14px; padding:14px;
    box-shadow: 0 6px 18px rgba(15,23,42,.06);
  }

  /* GRID COM SCROLL */
  .gantt-grid{
    border:1px solid var(--line);
    border-radius:12px;
    background:#fff;
    overflow:hidden;
  }
  .scroller{
    display:grid;
    grid-template-columns: var(--labelW) auto;
    max-width: 100%;
  }
  .timeline{ overflow:auto; }

  /* HEADER (rola junto) */
  .header{
    display:grid;
    grid-template-columns: var(--labelW) auto;
    position:sticky; top:0; z-index:5;
    background:#fff; border-bottom:1px solid var(--line);
  }
  .header .left{
    padding:.75rem .9rem; font-weight:700; color:var(--ink);
    border-right:1px solid var(--line);
  }
  .months{
    display:grid; height:32px; align-items:center;
    border-bottom:1px solid var(--line);
  }
  .month{
    text-align:center; font-weight:700; color:#374151; padding:.25rem 0;
    background:#fafafa; border-left:1px solid #f1f1f4;
  }
  .days{
    display:grid; height:46px; align-items:center;
  }
  .day{
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    gap:2px;
    text-align:center; border-left:1px solid var(--line);
    background:#fff;
  }
  .day .dow{ font-size:.72rem; line-height:1; color:#6b7280; letter-spacing:.2px; }
  .day .dnum{ font-size:.95rem; line-height:1; color:#111827; font-weight:700; }
  .day.weekend{ background:#f9f9ff; }
  .day.weekend .dow{ color:#4f46e5; font-weight:700; }

  /* LINHAS */
  .row{ display:grid; grid-template-columns: var(--labelW) auto; }
  .label{
    padding:.55rem .75rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    border-right:1px solid var(--line); border-bottom:1px solid var(--line);
    background:#fff; font-size:.92rem;
  }
  .track{
    position:relative; min-height:38px; background:#fff;
    border-bottom:1px solid var(--line);

    /* GRADE DE DIAS */
    background-image: repeating-linear-gradient(
      to right,
      transparent 0,
      transparent calc(var(--colW, 60px) - 1px),
      #eef0f4 calc(var(--colW, 60px) - 1px),
      #eef0f4 var(--colW, 60px)
    );
    background-size: var(--colW, 60px) 100%;
    background-repeat: repeat-x;
    background-position: left top;
    overflow: hidden;
  }
  .grid-lines{
    position:absolute; inset:0; pointer-events:none;
    background-image: repeating-linear-gradient(
      to right,
      transparent 0,
      transparent calc(var(--colW, 60px) - 1px),
      #eef0f4 calc(var(--colW, 60px) - 1px),
      #eef0f4 var(--colW, 60px)
    );
    background-size: var(--colW, 60px) 100%;
    background-repeat: repeat-x;
    background-position: left top;
  }
  .wknd-layer{ position:absolute; inset:0; pointer-events:none; }
  .wknd-cell{
    position:absolute; top:0; bottom:0;
    width: var(--colW, 60px);
    background: linear-gradient(to bottom, rgba(99,102,241,.08), rgba(99,102,241,.08));
    box-shadow: inset 0 0 0 1px rgba(99,102,241,.12);
    border-radius: 4px;
  }

  /* BARRAS */
  .bar{
    position:absolute; top:6px; height:26px; border-radius:10px;
    display:flex; align-items:center; gap:8px; padding:0 .6rem 0 .45rem;
    color:#fff; font-weight:700; font-size:.86rem;
    white-space:nowrap; text-overflow:ellipsis; cursor:grab;
    background: linear-gradient(90deg,var(--primary),var(--primary-2));
    box-shadow: 0 8px 20px rgba(79,70,229,.25), inset 0 1px 0 rgba(255,255,255,.25);
    transition: transform .12s ease, box-shadow .12s ease, filter .12s ease, opacity .12s ease;
    user-select: none;
  }
  .bar:active{ cursor:grabbing; }
  .bar:hover{ transform: translateY(-1px); box-shadow: 0 10px 28px rgba(79,70,229,.34), inset 0 1px 0 rgba(255,255,255,.28); filter: saturate(1.08); }

  .bar.confirmada{ background: linear-gradient(90deg, #4f46e5, #6366f1); }
  .bar.pendente{
    background:
      repeating-linear-gradient(45deg, rgba(255,255,255,.18) 0 8px, rgba(255,255,255,0) 8px 16px),
      linear-gradient(90deg, #f59e0b, #fbbf24);
    color:#111827;
  }
  .bar.cancelada{
    background: linear-gradient(90deg, #ef4444, #f87171);
    opacity:.75; outline: 2px dashed rgba(255,255,255,.9); outline-offset: -3px;
  }

  .status-ico{
    width:18px; height:18px; min-width:18px;
    display:inline-flex; align-items:center; justify-content:center;
    border-radius:999px;
    background:rgba(255,255,255,.2);
    border:1px solid rgba(255,255,255,.35);
  }

  .handle{ position:absolute; top:0; width:8px; height:100%; cursor:ew-resize; opacity:0; transition:opacity .1s ease; }
  .bar:hover .handle{ opacity:1; }
  .handle.left{ left:-3px; }
  .handle.right{ right:-3px; }

  .ghost{
    position:absolute; top:6px; height:26px; border-radius:8px;
    background: rgba(79,70,229,.25);
    border:1px dashed rgba(79,70,229,.65);
    pointer-events:none;
  }
  .ghost.blocked{ background: rgba(239,68,68,.2); border-color: rgba(239,68,68,.7); }

  /* Hover sutil da célula */
  .cell-hover{
    position:absolute; top:0; height:100%;
    width: var(--colW, 60px);
    pointer-events:none;
    background: rgba(79,70,229,.06);
    box-shadow: inset 0 0 0 1px rgba(79,70,229,.12);
    border-radius: 6px;
    transition: opacity .08s ease;
    opacity:.85;
  }
  .cell-hover.blocked{
    background: rgba(15,23,42,.05);
    box-shadow: inset 0 0 0 1px rgba(15,23,42,.08);
  }

  .legend{ display:flex; gap:12px; align-items:center; color:var(--muted); }
  .legend i{ width:14px; height:14px; display:inline-block; border-radius:4px; }
  .legend .c1{ background:linear-gradient(90deg,var(--primary),var(--primary-2)); }
  .legend .c2{ background:linear-gradient(90deg,#f59e0b,#fbbf24); }
  .legend .c3{ background:linear-gradient(90deg,#ef4444,#f87171); }

  /* TOOLTIP */
  .tooltip{
    position:fixed; z-index:70;
    background:#0b1022; color:#fff;
    border-radius:12px; padding:.6rem .7rem;
    box-shadow: 0 14px 40px rgba(2,6,23,.4);
    max-width: 320px; font-size:.9rem;
    backdrop-filter: blur(6px) saturate(120%);
    border:1px solid rgba(255,255,255,.08);
    pointer-events:none;
  }
  .tt-title{ font-weight:800; letter-spacing:.2px; margin-bottom:.15rem; }
  .tt-row{ display:flex; align-items:center; gap:.5rem; margin:.15rem 0; color:#d1d5db; }
  .pill{
    display:inline-flex; align-items:center; gap:.35rem;
    font-size:.78rem; font-weight:700; padding:.15rem .45rem;
    border-radius:999px; border:1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.08);
  }
  .pill.confirmada{ background:linear-gradient(90deg,#4f46e5,#6366f1); color:#fff; }
  .pill.pendente{ background:linear-gradient(90deg,#f59e0b,#fbbf24); color:#111827; }
  .pill.cancelada{ background:linear-gradient(90deg,#ef4444,#f87171); color:#fff; }

  /* POPOVER / MODAIS + TOAST */
  .popover{ position: fixed; z-index: 60; background:#fff; border:1px solid var(--line); border-radius:12px; box-shadow:0 16px 50px rgba(2,6,23,.18); width:min(92vw, 420px); }
  .pop-header{ padding:.75rem .9rem; border-bottom:1px solid var(--line); font-weight:700; }
  .pop-body{ padding:.8rem .9rem; display:flex; flex-direction:column; gap:.6rem; }
  .pop-row{ display:flex; gap:.5rem; }
  .pop-row input, .pop-row select{ flex:1; padding:.55rem .6rem; border:1px solid var(--line); border-radius:10px; }
  .pop-actions{ display:flex; justify-content:space-between; gap:.5rem; padding:.8rem .9rem; border-top:1px solid var(--line); }
  .btn{ border:1px solid var(--line); background:#fff; padding:.55rem .75rem; border-radius:10px; cursor:pointer; }
  .btn.primary{ background:linear-gradient(90deg,var(--primary),var(--primary-2)); color:#fff; border:0; }
  .btn.danger{ background:linear-gradient(90deg,#ef4444,#f87171); color:#fff; border:0; }
  .toast{ position:fixed; right:14px; bottom:14px; z-index:70; background:#0f172a; color:#fff; padding:.6rem .8rem; border-radius:10px; box-shadow:0 10px 30px rgba(2,6,23,.25); }
</style>

<div id="HospedAIGantt"></div>

<!-- React via CDN + Babel -->
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
{% verbatim %}
/** ====== Constantes / Utils ====== */
const LABEL_W = 160;
const COL_W   = 60;
const DAY_MS  = 86400000;

const API_CREATE = "/reservas/api/reservas/";
const API_UPDATE = (id)=> `/reservas/api/reservas/${id}/`;

function getCookie(name){
  const value=`; ${document.cookie}`;
  const parts=value.split(`; ${name}=`);
  if(parts.length===2) return parts.pop().split(";").shift();
}
const csrftoken = getCookie("csrftoken") || "";

function buildWindow(startISO, days){
  const start = new Date(startISO+"T00:00:00");
  const arr=[]; const groups=[];
  for(let i=0;i<days;i++){
    const d=new Date(start.getTime()+i*DAY_MS);
    arr.push({date:d, day:d.getDate(), month:d.getMonth(), year:d.getFullYear()});
    const key=`${d.getFullYear()}-${d.getMonth()}`;
    if(groups.length && groups[groups.length-1].key===key){
      groups[groups.length-1].span++;
    }else{
      groups.push({key,label:d.toLocaleDateString('pt-BR',{month:'long',year:'numeric'}),span:1});
    }
  }
  return {days:arr, groups};
}

const fmtDateTime = (iso) => {
  const d=new Date(iso);
  const p=n=>n<10?"0"+n:n;
  return `${p(d.getDate())}/${p(d.getMonth()+1)} ${p(d.getHours())}:${p(d.getMinutes())}`;
};
const diffNights = (startIso, endIso) => Math.max(1, Math.round((new Date(endIso) - new Date(startIso)) / DAY_MS));
const DOW_PT = ["Dom","Seg","Ter","Qua","Qui","Sex","Sáb"];

/* ===== ÍCONES DE STATUS ===== */
function StatusIcon({status, size=14}){
  const s = String(status||"confirmada").toLowerCase();
  const common = { width:size, height:size, viewBox:"0 0 24 24", fill:"none", stroke:"currentColor", strokeWidth:"2", strokeLinecap:"round", strokeLinejoin:"round" };
  const color = s==="pendente" ? "#111827" : "#ffffff";
  return (
    <span className="status-ico" aria-hidden="true">
      {s==="confirmada" && (
        <svg {...common}>
          <circle cx="12" cy="12" r="10" stroke={color} opacity="0.9"></circle>
          <path d="M8 12l3 3 5-6" stroke={color}></path>
        </svg>
      )}
      {s==="pendente" && (
        <svg {...common}>
          <circle cx="12" cy="12" r="10" stroke={color} opacity="0.9"></circle>
          <path d="M12 7v5l3 3" stroke={color}></path>
        </svg>
      )}
      {s==="cancelada" && (
        <svg {...common}>
          <circle cx="12" cy="12" r="10" stroke={color} opacity="0.9"></circle>
          <path d="M8 8l8 8M16 8l-8 8" stroke={color}></path>
        </svg>
      )}
    </span>
  );
}

/** ====== UI ====== */
function Toolbar({startISO,days,onChange,onReload}){
  const [start,setStart]=React.useState(startISO);
  const [win,setWin]=React.useState(String(days));
  React.useEffect(()=>{setStart(startISO);setWin(String(days));},[startISO,days]);
  const apply=()=>onChange(start,parseInt(win,10));
  return(
    <div className="gantt-toolbar">
      <div className="side">
        <strong>{new Date(start+"T00:00:00").toLocaleDateString('pt-BR',{month:'long',year:'numeric'})}</strong>
      </div>
      <div className="side">
        <input type="date" value={start} onChange={e=>setStart(e.target.value)}/>
        <select value={win} onChange={e=>setWin(e.target.value)}>
          <option value="30">30 dias</option>
          <option value="60">60 dias</option>
          <option value="90">90 dias</option>
        </select>
        <button onClick={apply}>Aplicar</button>
        <button onClick={onReload}>Recarregar</button>
      </div>
      <div className="legend">
        <span><i className="c1"></i> Confirmada</span>
        <span><i className="c2"></i> Pendente</span>
        <span><i className="c3"></i> Cancelada</span>
      </div>
    </div>
  );
}

function Header({days,groups}){
  const widthPx=days.length*COL_W+"px";
  const cols=`repeat(${days.length},${COL_W}px)`;
  return(
    <div className="header" style={{'--labelW':LABEL_W+'px'}}>
      <div className="left">Quarto</div>
      <div className="right">
        <div className="months" style={{gridTemplateColumns:cols,width:widthPx}}>
          {groups.map((g,i)=><div key={i} className="month" style={{gridColumn:`span ${g.span}`}}>{g.label}</div>)}
        </div>
        <div className="days" style={{gridTemplateColumns:cols,width:widthPx}}>
          {days.map((d,i)=>{
            const w = d.date.getDay();
            const isWknd = (w===0 || w===6);
            return (
              <div key={i} className={`day ${isWknd?'weekend':''}`}>
                <span className="dow">{DOW_PT[w]}</span>
                <span className="dnum">{d.day}</span>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}

/* ===== Tooltip ===== */
function ReservationTooltip({tip}){
  if(!tip || !tip.data) return null;
  const {x,y,data} = tip;
  const nights = diffNights(data.start, data.end);
  const style = { left: Math.min(window.innerWidth-340, x+14), top:  Math.min(window.innerHeight-140, y+14) };
  return (
    <div className="tooltip" style={style}>
      <div className="tt-title">{data.cliente || "Reserva"}</div>
      <div className="tt-row">
        <span className={`pill ${data.status || 'confirmada'}`}>
          <StatusIcon status={data.status} />
          {(data.status || 'confirmada').toUpperCase()}
        </span>
        {data.roomLabel && <span style={{opacity:.85}}>{data.roomLabel}</span>}
      </div>
      <div className="tt-row">Check-in: <strong>{fmtDateTime(data.start)}</strong></div>
      <div className="tt-row">Check-out: <strong>{fmtDateTime(data.end)}</strong></div>
      <div className="tt-row">Duração: <strong>{nights} noite{nights>1?'s':''}</strong></div>
    </div>
  );
}

/* ===== helpers ===== */
function overlaps(aStart,aEnd,bStart,bEnd){ return aStart < bEnd && aEnd > bStart; }

/* ===== Row com drag/resize + DRAG GUARD + ghostRef ===== */
function Row({room, windowStart, windowDays, onBarClick, onCreateRequest, onBarHover, onBarLeave, allRowsMeta, rowIndex}){
  const base=new Date(windowStart+"T00:00:00");
  const reservas=(room.reservas||[]).map(r=>({...r,s:new Date(r.start),e:new Date(r.end), roomLabel: room.label}));
  const trackRef = React.useRef(null);

  const [hoverIdx,setHoverIdx]=React.useState(null);
  const [blocked,setBlocked]=React.useState(false);

  const moveRef = React.useRef(null);
  const draggingRef = React.useRef(null);
  const dragGuardRef = React.useRef(false);
  const [ghost,setGhost] = React.useState(null);
  const ghostRef = React.useRef(null);              // <<< NOVO
  React.useEffect(()=>{ ghostRef.current = ghost; }, [ghost]);  // sempre manter atualizado

  React.useEffect(()=>()=>{ if(moveRef.current) window.removeEventListener("mousemove", moveRef.current); },[]);

  const isBlocked=(idx)=>{
    const dayStart=new Date(base.getTime()+idx*DAY_MS);
    const dayEnd=new Date(base.getTime()+(idx+1)*DAY_MS);
    return reservas.some(r=>r.status!=="cancelada"&&r.s<dayEnd&&r.e>dayStart);
  };

  const onMove=(e)=>{
    const rect=e.currentTarget.getBoundingClientRect();
    let idx=Math.floor((e.clientX-rect.left)/COL_W);
    if(idx<0)idx=0;if(idx>=windowDays)idx=windowDays-1;
    setHoverIdx(idx);setBlocked(isBlocked(idx));
  };
  const onLeave=()=>{setHoverIdx(null);setBlocked(false); onBarLeave?.();};

  const onTrackClick=(e)=>{
    if (dragGuardRef.current) return; // não crie após drag
    if(hoverIdx==null||blocked)return;
    const start=new Date(base.getTime()+hoverIdx*DAY_MS);
    const anchor={ x:e.clientX, y:e.clientY + 28 };
    onCreateRequest?.({ roomId:room.id, roomLabel:room.label, startISO:start.toISOString(), anchor });
  };

  const snapIndex = (clientX)=>{
    const el = trackRef.current;
    if(!el) return 0;
    const rect = el.getBoundingClientRect();
    let idx = Math.round((clientX - rect.left)/COL_W);
    if(idx<0) idx=0;
    if(idx>windowDays) idx=windowDays;
    return idx;
  };
  const dateFromIdx = (idx)=> new Date(base.getTime()+idx*DAY_MS);
  const idxFromDate = (d)=> Math.round((d - base)/DAY_MS);

  function hasConflict(qReservas, ignoreId, start, end){
    return qReservas.some(r=>{
      if(ignoreId && r.id===ignoreId) return false;
      if(r.status==="cancelada") return false;
      const rs = new Date(r.start||r.s);
      const re = new Date(r.end||r.e);
      return overlaps(start,end,rs,re);
    });
  }
  function rowIndexFromClientY(clientY){
    const g = allRowsMeta;
    if(!g?.rowTop || !g?.rowH) return rowIndex;
    const i = Math.floor((clientY - g.rowTop)/g.rowH);
    return Math.max(0, Math.min(g.count-1, i));
  }

  function beginGlobalDrag(moveFn, upFn){
    dragGuardRef.current = true;
    document.body.style.userSelect = "none";
    moveRef.current = (e)=>{ e.preventDefault(); moveFn(e); };
    const up = (e)=>{
      // Chama primeiro o handler de mouseup (usa ghostRef), depois encerra drag
      upFn?.(e);
      endGlobalDrag();
    };
    window.addEventListener("mousemove", moveRef.current, {passive:false});
    window.addEventListener("mouseup", up, {once:true});
  }
  function endGlobalDrag(){
    if(moveRef.current) window.removeEventListener("mousemove", moveRef.current);
    moveRef.current = null;
    document.body.style.userSelect = "";
    setTimeout(()=>{ dragGuardRef.current = false; }, 80);
  }

  function startDragMove(e, r){
    e.stopPropagation(); e.preventDefault();
    const rect = trackRef.current?.getBoundingClientRect();
    const offsetX = rect ? (e.clientX - (rect.left + (idxFromDate(r.s)*COL_W))) : 0;
    draggingRef.current = { mode:"move", resId:r.id, start:new Date(r.s), end:new Date(r.e), offsetX, rowIndex };
    setHoverIdx(null);
    beginGlobalDrag(onMouseMoveDrag, onMouseUpDrag);
  }
  function startResize(e, r, side){
    e.stopPropagation(); e.preventDefault();
    draggingRef.current = { mode:(side==="L"?"resizeL":"resizeR"), resId:r.id, start:new Date(r.s), end:new Date(r.e), rowIndex };
    setHoverIdx(null);
    beginGlobalDrag(onMouseMoveDrag, onMouseUpDrag);
  }

  function onMouseMoveDrag(e){
    const dragging = draggingRef.current;
    if(!dragging) return;

    const destRow = (dragging.mode==="move") ? rowIndexFromClientY(e.clientY) : dragging.rowIndex;
    let s = new Date(dragging.start);
    let t = new Date(dragging.end);

    if(dragging.mode==="move"){
      const el = trackRef.current;
      const rect = el ? el.getBoundingClientRect() : {left:0};
      const leftPx = e.clientX - rect.left - dragging.offsetX;
      const startIdx = Math.round(leftPx / COL_W);
      const durDays = Math.max(1, Math.round((t - s)/DAY_MS));
      s = dateFromIdx(Math.max(0, Math.min(windowDays-1, startIdx)));
      t = new Date(s.getTime() + durDays*DAY_MS);
      if(t > new Date(base.getTime()+windowDays*DAY_MS)){
        t = new Date(base.getTime()+windowDays*DAY_MS);
        s = new Date(t.getTime() - durDays*DAY_MS);
      }
    }else if(dragging.mode==="resizeL"){
      const idx = snapIndex(e.clientX);
      const maxIdx = idxFromDate(t)-1;
      const clamped = Math.max(0, Math.min(maxIdx, idx));
      s = dateFromIdx(clamped);
    }else if(dragging.mode==="resizeR"){
      const idx = snapIndex(e.clientX);
      const minIdx = idxFromDate(s)+1;
      const clamped = Math.max(minIdx, Math.min(windowDays, idx));
      t = dateFromIdx(clamped);
    }

    const targetRow = allRowsMeta.rows[destRow];
    const conflict = hasConflict(targetRow.reservas, dragging.resId, s, t);

    const left = Math.max(0, Math.min(windowDays*COL_W, idxFromDate(s)*COL_W));
    const width = Math.max(COL_W, Math.round((t - s)/DAY_MS)*COL_W);
    const g = {left, width, blocked:conflict, destRow, s, t};

    ghostRef.current = g;   // <<< manter ref atualizado
    setGhost(g);
  }

  async function onMouseUpDrag(){
    const dragging = draggingRef.current;
    const g = ghostRef.current;   // <<< usa o ref, não o state do closure
    draggingRef.current = null;
    setGhost(null);

    if(!dragging || !g) return;     // se não moveu de verdade
    if(g.blocked) return;           // conflito detectado

    const payload = { data_entrada: g.s.toISOString(), data_saida: g.t.toISOString() };
    if(g.destRow !== dragging.rowIndex){
      payload.quarto = allRowsMeta.rows[g.destRow].id;
    }
    try{
      const res = await fetch(API_UPDATE(dragging.resId),{
        method:"PATCH",
        headers:{ "Content-Type":"application/json", "X-CSRFToken": getCookie("csrftoken")||"" },
        body: JSON.stringify(payload)
      });
      if(!res.ok){
        const j = await res.json().catch(()=>({}));
        throw new Error(j.error||`Erro ${res.status}`);
      }
      window.dispatchEvent(new CustomEvent("gantt:reload"));
    }catch(err){
      console.error(err);
    }
  }

  const clamp=(s,e)=>{
    const winStart=base.getTime();const winEnd=base.getTime()+windowDays*DAY_MS;
    const S=Math.max(s.getTime(),winStart);const E=Math.min(e.getTime(),winEnd);
    if(E<=S)return null;const fs=(S-winStart)/DAY_MS;const fe=(E-winStart)/DAY_MS;
    return {left:fs*COL_W,width:(fe-fs)*COL_W};
  };

  const wkndIdx = React.useMemo(()=>{
    const arr=[];
    for(let i=0;i<windowDays;i++){
      const d=new Date(base.getTime()+i*DAY_MS);
      const w=d.getDay();
      if(w===0||w===6) arr.push(i);
    }
    return arr;
  },[windowStart, windowDays]);

  return(
    <div className="row" style={{'--labelW':LABEL_W+'px'}}>
      <div className="label">{room.label}</div>
      <div className="track" ref={trackRef} style={{'--colW':COL_W+'px', width:(windowDays*COL_W)+'px'}}
        onMouseMove={onMove} onMouseLeave={onLeave} onClick={onTrackClick}>

        <div className="wknd-layer" style={{'--colW':COL_W+'px'}}>
          {wkndIdx.map(i=>(<div key={i} className="wknd-cell" style={{left:(i*COL_W)+'px'}}></div>))}
        </div>
        <div className="grid-lines" style={{'--colW':COL_W+'px'}}></div>

        {hoverIdx!=null&&(
          <div className={`cell-hover ${blocked?'blocked':''}`} style={{left:(hoverIdx*COL_W)+'px'}}/>
        )}
        {ghost && (<div className={`ghost ${ghost.blocked?'blocked':''}`} style={{left:ghost.left+'px', width:ghost.width+'px'}}></div>)}

        {reservas.map(r=>{
          const proj=clamp(r.s,r.e); if(!proj) return null;
          const st = (r.status||'confirmada');
          const cls=`bar ${st}`;
          return(
            <div key={r.id} className={cls}
              style={{left:proj.left+'px',width:proj.width+'px'}}
              onMouseEnter={(evt)=> onBarHover?.(evt, r)}
              onMouseMove={(evt)=> onBarHover?.(evt, r)}
              onMouseLeave={()=> onBarLeave?.()}
              onMouseDown={(evt)=> startDragMove(evt, r)}
              onClick={(evt)=>{ if (dragGuardRef.current) return; evt.stopPropagation(); onBarClick?.(evt,r); }}>
              <StatusIcon status={st}/>
              <span>{r.cliente||'—'}</span>
              <span className="handle left"  onMouseDown={(e)=>startResize(e,r,"L")}></span>
              <span className="handle right" onMouseDown={(e)=>startResize(e,r,"R")}></span>
            </div>
          );
        })}
      </div>
    </div>
  );
}

function Grid({payload, onBarClick, onCreateRequest, onBarHover, onBarLeave, onReload}){
  const {days,groups}=buildWindow(payload.window_start, payload.window_days);

  const containerRef = React.useRef(null);
  const [rowGeom,setRowGeom] = React.useState({rowTop:0,rowH:40});
  const rowsMeta = React.useMemo(()=>{
    const rows = payload.quartos.map(q=>({
      id:q.id, label:q.label, reservas:q.reservas||[]
    }));
    return {rows, count: rows.length};
  },[payload]);

  React.useEffect(()=>{
    const t = containerRef.current?.querySelector(".track");
    const r = containerRef.current?.querySelector(".row");
    if(t && r){
      const tb = t.getBoundingClientRect();
      const rb = r.getBoundingClientRect();
      setRowGeom({rowTop: tb.top, rowH: rb.height});
    }
  },[payload]);

  React.useEffect(()=>{
    const h=()=> onReload();
    window.addEventListener("gantt:reload",h);
    return ()=> window.removeEventListener("gantt:reload",h);
  },[onReload]);

  const widthPx=days.length*COL_W+"px";
  const cols=`repeat(${days.length},${COL_W}px)`;

  return(
    <div className="gantt-grid">
      <div className="scroller" style={{'--labelW':LABEL_W+'px'}}>
        <div className="labels"></div>
        <div className="timeline" ref={containerRef}>
          <div className="header" style={{'--labelW':LABEL_W+'px'}}>
            <div className="left">Quarto</div>
            <div className="right">
              <div className="months" style={{gridTemplateColumns:cols,width:widthPx}}>
                {groups.map((g,i)=><div key={i} className="month" style={{gridColumn:`span ${g.span}`}}>{g.label}</div>)}
              </div>
              <div className="days" style={{gridTemplateColumns:cols,width:widthPx}}>
                {days.map((d,i)=>{
                  const w=d.date.getDay(); const isWknd=(w===0||w===6);
                  return (
                    <div key={i} className={`day ${isWknd?'weekend':''}`}>
                      <span className="dow">{DOW_PT[w]}</span>
                      <span className="dnum">{d.day}</span>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>

          <div className="rows">
            {payload.quartos.map((q,idx)=>(
              <Row key={q.id}
                room={q}
                windowStart={payload.window_start}
                windowDays={payload.window_days}
                onBarClick={onBarClick}
                onCreateRequest={onCreateRequest}
                onBarHover={onBarHover}
                onBarLeave={onBarLeave}
                allRowsMeta={{...rowsMeta, ...rowGeom}}
                rowIndex={idx}
              />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

/* ---------- Utilitários ---------- */
function placeNear(x,y,width=420,height=300,margin=10){
  const vw=window.innerWidth, vh=window.innerHeight;
  let left=x+margin, top=y+margin;
  if(left+width>vw) left=Math.max(10, x-width-margin);
  if(top+height>vh) top=Math.max(10, y-height-margin);
  return {left, top};
}
function Toast({msg}){ if(!msg) return null; return <div className="toast">{msg}</div>; }
const API_TOAST = { ok:(s)=>s, err:(e)=> (typeof e==='string'? e : (e?.message || 'Erro inesperado')) };

/* ---------- Popovers (sem mudanças funcionais) ---------- */
function EditReservationPopover({anchor, reserva, onClose, onSaved, toast}){
  const [start,setStart]=React.useState("");
  const [end,setEnd]=React.useState("");
  React.useEffect(()=>{
    if(!reserva) return;
    const toLocal=(iso)=>{ const d=new Date(iso); const p=n=>n<10?"0"+n:n;
      return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}T${p(d.getHours())}:${p(d.getMinutes())}`; };
    setStart(toLocal(reserva.start)); setEnd(toLocal(reserva.end));
  },[reserva]);
  if(!reserva) return null;
  const pos=placeNear(anchor.x, anchor.y, 420, 260);
  const patch=async(body)=>{
    const r=await fetch(API_UPDATE(reserva.id),{
      method:"PATCH",
      headers:{ "Content-Type":"application/json", "X-CSRFToken": getCookie("csrftoken")||"" },
      body:JSON.stringify(body)
    });
    if(!r.ok){ const j=await r.json().catch(()=>({})); throw new Error(j.error||`Falha (${r.status})`); }
    return r.json();
  };
  const saveDates=async()=>{ try{
    await patch({data_entrada:new Date(start).toISOString(), data_saida:new Date(end).toISOString()});
    onSaved(); onClose();
  }catch(e){ toast(API_TOAST.err(e)); } };
  const toConfirm=async()=>{ try{ await patch({status:"confirmada"}); onSaved(); onClose(); }catch(e){ toast(API_TOAST.err(e)); } };
  const toCancel=async()=>{ try{ await patch({status:"cancelada"}); onSaved(); onClose(); }catch(e){ toast(API_TOAST.err(e)); } };

  return(
    <div className="popover" style={{left:pos.left, top:pos.top}}>
      <div className="pop-header">Editar reserva — {reserva.cliente||"—"}</div>
      <div className="pop-body">
        <div className="pop-row"><input type="datetime-local" value={start} onChange={e=>setStart(e.target.value)}/></div>
        <div className="pop-row"><input type="datetime-local" value={end} onChange={e=>setEnd(e.target.value)}/></div>
      </div>
      <div className="pop-actions">
        <button className="btn" onClick={toCancel}>Cancelar reserva</button>
        <div style={{display:"flex", gap:8}}>
          <button className="btn" onClick={toConfirm}>Confirmar</button>
          <button className="btn primary" onClick={saveDates}>Salvar</button>
          <button className="btn" onClick={onClose}>Fechar</button>
        </div>
      </div>
    </div>
  );
}

function CreateReservationPopover({anchor, draft, quartos, onClose, onSaved, toast}){
  const [form,setForm]=React.useState({
    quarto: draft?.roomId || "", nome_cliente:"", email:"", telefone:"",
    status:"confirmada", data_entrada:"", data_saida:"", tipo_quarto:""
  });
  React.useEffect(()=>{
    if(!draft) return;
    const start=new Date(draft.startISO);
    const end=new Date(start.getTime()+DAY_MS);
    const p=n=>n<10?"0"+n:n;
    const fmt=d=>`${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}T${p(d.getHours())}:${p(d.getMinutes())}`;
    const s=new Date(start); s.setHours(14,0,0,0);
    const e=new Date(end);   e.setHours(11,0,0,0);
    setForm(f=>({...f, quarto:draft.roomId, data_entrada:fmt(s), data_saida:fmt(e)}));
  },[draft]);
  if(!draft) return null;
  const pos=placeNear(anchor.x, anchor.y, 420, 360);
  const onChange=(k,v)=>setForm(s=>({...s,[k]:v}));
  const submit=async()=>{ try{
    const payload={
      quarto:Number(form.quarto),
      nome_cliente:form.nome_cliente.trim(),
      email:form.email.trim(),
      telefone:form.telefone.trim(),
      status:form.status,
      data_entrada:new Date(form.data_entrada).toISOString(),
      data_saida:new Date(form.data_saida).toISOString(),
      tipo_quarto:form.tipo_quarto||undefined
    };
    const r=await fetch(API_CREATE,{
      method:"POST",
      headers:{ "Content-Type":"application/json", "X-CSRFToken": getCookie("csrftoken")||"" },
      body:JSON.stringify(payload)
    });
    if(!r.ok){ const j=await r.json().catch(()=>({})); throw new Error(j.error||`Falha (${r.status}) ao criar`); }
    await r.json(); onSaved(); onClose();
  }catch(e){ toast(e.message||"Erro ao criar"); } };
  return(
    <div className="popover" style={{left:pos.left, top:pos.top}}>
      <div className="pop-header">Nova reserva — {draft.roomLabel}</div>
      <div className="pop-body">
        <div className="pop-row">
          <select value={form.quarto} onChange={e=>onChange("quarto", e.target.value)}>
            <option value="">Selecione o quarto</option>
            {quartos.map(q=> <option key={q.id} value={q.id}>{q.label}</option>)}
          </select>
        </div>
        <div className="pop-row">
          <input placeholder="Nome do cliente" value={form.nome_cliente} onChange={e=>onChange("nome_cliente", e.target.value)}/>
        </div>
        <div className="pop-row">
          <input type="email" placeholder="Email" value={form.email} onChange={e=>onChange("email", e.target.value)}/>
          <input placeholder="Telefone" value={form.telefone} onChange={e=>onChange("telefone", e.target.value)}/>
        </div>
        <div className="pop-row">
          <select value={form.status} onChange={e=>onChange("status", e.target.value)}>
            <option value="confirmada">Confirmada</option>
            <option value="pendente">Pendente</option>
            <option value="cancelada">Cancelada</option>
          </select>
          <select value={form.tipo_quarto} onChange={e=>onChange("tipo_quarto", e.target.value)}>
            <option value="">Tipo (opcional)</option>
            <option value="standard">Standard</option>
            <option value="luxo">Luxo</option>
            <option value="suite">Suite</option>
          </select>
        </div>
        <div className="pop-row">
          <input type="datetime-local" value={form.data_entrada} onChange={e=>onChange("data_entrada", e.target.value)}/>
          <input type="datetime-local" value={form.data_saida} onChange={e=>onChange("data_saida", e.target.value)}/>
        </div>
      </div>
      <div className="pop-actions">
        <div></div>
        <div style={{display:"flex", gap:8}}>
          <button className="btn" onClick={onClose}>Fechar</button>
          <button className="btn primary" onClick={submit}>Salvar</button>
        </div>
      </div>
    </div>
  );
}

/* ---------- App ---------- */
function App(){
  const today=new Date();
  const defStart=new Date(today.getFullYear(),today.getMonth(),1);
  const [startISO,setStartISO]=React.useState(defStart.toISOString().slice(0,10));
  const [winDays,setWinDays]=React.useState(60);
  const [data,setData]=React.useState(null);
  const [loading,setLoading]=React.useState(false);

  const [toastMsg,setToastMsg]=React.useState("");
  const toast=(m)=>{ setToastMsg(m); setTimeout(()=>setToastMsg(""), 2500); };

  const [editAnchor,setEditAnchor]=React.useState(null);
  const [editRes,setEditRes]=React.useState(null);

  const [createAnchor,setCreateAnchor]=React.useState(null);
  const [createDraft,setCreateDraft]=React.useState(null);

  const [tip,setTip]=React.useState(null);

  const load=async()=>{
    setLoading(true);
    try{
      const url=`/reservas/api/gantt_window/?start=${startISO}&days=${winDays}`;
      const r=await fetch(url);
      const j=await r.json();
      setData(j);
    }finally{ setLoading(false); }
  };
  React.useEffect(()=>{ load(); }, [startISO, winDays]);

  const onBarClick=(evt,res)=>{ setEditAnchor({x:evt.clientX, y:evt.clientY}); setEditRes(res); };
  const onCreateRequest=({roomId, roomLabel, startISO, anchor})=>{ setCreateAnchor(anchor); setCreateDraft({roomId, roomLabel, startISO}); };

  const quartosFlat = React.useMemo(()=> data ? data.quartos.map(q=>({id:q.id, label:q.label})) : [], [data]);
  const handleBarHover = (evt, res) => setTip({ x: evt.clientX, y: evt.clientY, data: res });
  const handleBarLeave = () => setTip(null);

  return(
    <div className="gantt-wrap">
      <Toolbar
        startISO={startISO}
        days={winDays}
        onChange={(s,d)=>{ setStartISO(s); setWinDays(d); }}
        onReload={load}
      />
      {loading}
      {data && (
        <Grid
          payload={data}
          onBarClick={onBarClick}
          onCreateRequest={onCreateRequest}
          onBarHover={handleBarHover}
          onBarLeave={handleBarLeave}
          onReload={load}
        />
      )}

      {editRes && editAnchor && (
        <EditReservationPopover
          anchor={editAnchor}
          reserva={editRes}
          onClose={()=>{ setEditRes(null); setEditAnchor(null); }}
          onSaved={load}
          toast={(m)=>setToastMsg(m)}
        />
      )}

      {createDraft && createAnchor && (
        <CreateReservationPopover
          anchor={createAnchor}
          draft={createDraft}
          quartos={quartosFlat}
          onClose={()=>{ setCreateDraft(null); setCreateAnchor(null); }}
          onSaved={load}
          toast={(m)=>setToastMsg(m)}
        />
      )}

      <ReservationTooltip tip={tip}/>
      <Toast msg={toastMsg}/>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("HospedAIGantt"));
root.render(<App />);
{% endverbatim %}
</script>
{% endblock %}
